Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.Strings.String.
Require Import StructTact.StructTactics.
Require Import Omega.
Require Import Coq.Logic.Eqdep_dec.
Require Import Equations.Equations.

Require Import CakeSem.Utils.
Require Import FFI.
Require Import CakeSem.Namespace.
Require Import CakeSem.CakeAST.
Require Import CakeSem.SemanticsAux.
Require Import CakeSem.Evaluate.
Require Import CakeSem.TypeSystem.
Require Import CakeSem.ValueTypes.

Require Import NoBasis.

Definition init_env : sem_env val := empty_sem_env.
Definition init_store := empty_store val.
Parameter init_ffi_st : ffi_state nat.
Definition init_state := Build_state 0 init_store init_ffi_st 0 0.

(* my_env is the environment generated by calling evaluate_decs f init_state init_env prog *)
(* with a large enought f to fully evaluate all expressions in prog *)
Definition my_env :=
  {| sev := [(Short "answer",
              Conv (Some (TypeStamp "S" 0))
                   [Conv (Some (TypeStamp "S" 0))
                         [Conv (Some (TypeStamp "S" 0))
                               [Conv (Some (TypeStamp "S" 0))
                                     [Conv (Some (TypeStamp "S" 0)) [Conv (Some (TypeStamp "O" 0)) []]]]]]);
               (Short "three",
                Conv (Some (TypeStamp "S" 0))
                     [Conv (Some (TypeStamp "S" 0))
                           [Conv (Some (TypeStamp "S" 0)) [Conv (Some (TypeStamp "O" 0)) []]]]);
               (Short "two",
                Conv (Some (TypeStamp "S" 0)) [Conv (Some (TypeStamp "S" 0)) [Conv (Some (TypeStamp "O" 0)) []]]);
               (Short "plus",
                Recclosure
                  {| sev := []; sec := [(Short "S", (1, TypeStamp "S" 0)); (Short "O", (0, TypeStamp "O" 0))] |}
                  [("plus", "x",
                    EFun "y"
                         (ELannot
                            (EMat (ELannot (EVar (Short "x")) [0])
                                  [(Pcon (Some (Short "O")) [], ELannot (EVar (Short "y")) [0]);
                                     (Pcon (Some (Short "S")) [Pvar "xp"],
                                      ELannot
                                        (ECon (Some (Short "S"))
                                              [EApp Opapp
                                                    [ELannot
                                                       (EApp Opapp
                                                             [ELannot (EVar (Short "plus")) [0]; ELannot (EVar (Short "xp")) [0]])
                                                       [0]; ELannot (EVar (Short "y")) [0]]]) [0])]) [0]))] "plus")];
     sec := [(Short "S", (1, TypeStamp "S" 0)); (Short "O", (0, TypeStamp "O" 0))] |}.

(* The state produced by the same call as my_env *)
Definition my_st := {| clock := 0; refs := []; ffi := init_ffi_st; next_type_stamp := 1; next_exn_stamp := 0 |}.

(* relation that checks whether one namespace is structurally equivalent to another barring elements *)
(* added to the front  *)
Inductive namespace_extended (M N V : Type) : namespace M N V -> namespace M N V -> Prop :=
| Reflexive_ns_extended : forall (ns : namespace M N V), namespace_extended M N V ns ns
| Extended_by_one : forall (ns0 ns1 : namespace M N V) (p : ident M N * V),
    namespace_extended M N V ns0 ns1 -> namespace_extended M N V ns0 (p::ns1).

Lemma empty_always_extendable :
  forall (M N V : Type) (ns : namespace M N V), namespace_extended M N V [] ns.
Proof.
  induction ns; constructor; assumption.
Qed.

Theorem namespace_extended_dec :
  forall (M N V : Type)
    (m_dec : forall (m0 m1 : M), {m0 = m1} + {m0 <> m1})
    (n_dec : forall (n0 n1 : N), {n0 = n1} + {n0 <> n1})
    (v_dec : forall (v0 v1 : V), {v0 = v1} + {v0 <> v1})
    (ns0 ns1 : namespace M N V),
    {namespace_extended M N V ns0 ns1} + {not (namespace_extended M N V ns0 ns1)}.
Proof.
  intros M N V m_dec n_dec v_dec.
  induction ns0; induction ns1.
  - left. constructor.
  - left. apply empty_always_extendable.
  - right. intro contra. inv contra.
  - destruct IHns1.
    + left. constructor. assumption.
    + destruct (list_eq_dec (pair_eq_dec _ _ (ident_eq_dec _ _ m_dec n_dec) v_dec) ns0 ns1).
      destruct (pair_eq_dec _ _ (ident_eq_dec _ _ m_dec n_dec) v_dec a a0).
      subst.
      left. constructor.
      right. intro contra.
      subst.
      inv contra. congruence.
      apply n. congruence.
      right. intro contra.
      inv contra. congruence.
      apply n. congruence.
Qed.

Definition environment_extended (env0 env1 : sem_env val) : Prop :=
  namespace_extended _ _ _ (sev env0) (sev env1) /\
  namespace_extended _ _ _ (sec env0) (sec env1).


Definition namespace_subset (M N V : Type) (ns0 ns1 : namespace M N V)
           (m_dec : forall (m0 m1 : M), {m0 = m1} + {m0 <> m1})
           (n_dec : forall (n0 n1 : N), {n0 = n1} + {n0 <> n1})
  : Prop :=
  forall (id : ident M N) (v : V),
    nsLookup (ident_eq_dec _ _ m_dec n_dec) id ns0 = Some v ->
    nsLookup (ident_eq_dec _ _ m_dec n_dec) id ns1 = Some v.

Definition env_subset (env0 env1 : sem_env val) : Prop :=
  namespace_subset _ _ _ (sev env0) (sev env1) string_dec string_dec /\
  namespace_subset _ _ _ (sec env0) (sec env1) string_dec string_dec.

Theorem namespace_subset_dec :
  forall (M N V : Type) (ns0 ns1 : namespace M N V)
    (m_dec : forall (m0 m1 : M), {m0 = m1} + {m0 <> m1})
    (n_dec : forall (n0 n1 : N), {n0 = n1} + {n0 <> n1}),
    {namespace_subset _ _ _ ns0 ns1 m_dec n_dec} + {not (namespace_subset _ _ _ ns0 ns1 m_dec n_dec)}.
Abort.

(* Relates any nat to a structurally similar constructor value in CakeML. *)
(* Based only on the name of the constructor *)
Inductive nat_rel_cake_nat (typestamp : nat) : nat -> val -> Prop :=
| zero_rel : nat_rel_cake_nat typestamp 0 (Conv (Some (TypeStamp "O" typestamp)) [])
| suc_rel  : forall (n : nat) (prev : val), nat_rel_cake_nat typestamp n prev -> nat_rel_cake_nat typestamp (S n) (Conv (Some (TypeStamp "S" typestamp)) [prev]).

Fixpoint nat_to_cake_nat (typestamp : nat) (n : nat) : val :=
  match n with
  | O => (Conv (Some (TypeStamp "O" typestamp)) [])
  | S n' => (Conv (Some (TypeStamp "S" typestamp)) [nat_to_cake_nat typestamp n'])
  end.

Lemma nat_to_cake_nat_rel : forall (typestamp n : nat), nat_rel_cake_nat typestamp n (nat_to_cake_nat typestamp n).
Proof.
  induction n; simpl; constructor; assumption.
Qed.

Ltac step_fuel_in fuel H := destruct fuel; simpl in H.

(* A used to just be Type for the genric version of state but changing to nat here just to avoid *)
(* renaming everything *)
Definition A := nat.

Definition evaluate_diverges (st : state A) (env : sem_env val) (e : exp) : Prop :=
  forall (fuel : nat), exists (st' : state A), evaluate [e] fuel st env = (st', Rerr (Rabort Rtimeout_error)).

Lemma exists_fuel_no_divergence : forall (st : state A) (env : sem_env val) (e : exp) (v : val),
    (exists (f : nat), evaluate [e] f st env = (st, Rval [v])) -> ~ evaluate_diverges st env e.
Proof.
  intros st env e.
  induction e;
    intros va H contra;
    inversion H as [f H']; specialize (contra f); inversion contra as [st' contra']; clear H; clear contra;
      rewrite H' in contra'; inversion contra'.
Qed.

Ltac inv H := inversion H; subst; clear H.

Lemma Forall''_app : forall (T : Type) (P : T -> Type) (l : list T) (a : T), Forall'' P l -> P a -> Forall'' P (l ++ [a]).
  intros.
  induction l.
  constructor.
  assumption.
  assumption.
  inv X.
  constructor.
  assumption.
  apply IHl.
  assumption.
Qed.

Lemma Forall''_rev : forall (T : Type) (P : T -> Type) (l : list T),
    Forall'' P l -> Forall'' P (rev l).
Proof.
  intros.
  induction l.
  constructor.
  inv X.
  simpl.
  apply Forall''_app; auto.
Qed.

Lemma eval_or_match_sing : forall (e : exp) (f : nat) (st st' : state A) (env : sem_env val) (vs : list val),
    eval_or_match true [e] f st env uu uu = (st', Rval vs) -> exists (v : val), vs = [v].
Proof.
  intros e f.
  revert e.
  induction f; induction e; intros.
  - unfold evaluate in H. simp eval_or_match in H.
    destruct (do_con_check (sec env) o (Datatypes.length l)).
    break_let.
    destruct r.
    destruct (build_conv (sec env) o (rev l0)); inv H; eauto.
    inv H.
    inv H.

 - unfold evaluate in H. simp eval_or_match in H. simp eval_or_match in H.
   destruct (nsLookup ident_string_dec i (sev env)); inv H; eauto.

 - unfold evaluate in H. simp eval_or_match in H. simp eval_or_match in H.
   inv H.
   eauto.

 - unfold evaluate in H. simp eval_or_match in H. simp eval_or_match in H. inv H.

 - unfold evaluate in H. simp eval_or_match in H.
   induction X.
   break_let.
   simp eval_or_match in H.
   destruct r. apply IHe in Heqp.
   destruct Heqp.
   rewrite H0 in *.
   simp eval_or_match in H.
   inv H.
   inv H.
   break_let.
   destruct r.
   apply IHe in Heqp0.
   destruct Heqp0.
   rewrite H0 in *. clear H0.
   destruct x.
   simpl in *.
   simp eval_or_match in H.
   break_if.
   break_match.
   apply IHX in H.
   apply H.
   inv H.
   apply p in H.
   apply H.
   inv H.
   inv H.

 - unfold evaluate in H. simp eval_or_match in H.

 - unfold evaluate in H. simp eval_or_match in H.
    destruct (do_con_check (sec env) o (Datatypes.length l)).
    break_let.
    destruct r.
    destruct (build_conv (sec env) o (rev l0)); inv H; eauto.
    inv H.
    inv H.

 - unfold evaluate in H. simp eval_or_match in H.
   destruct (nsLookup ident_string_dec i (sev env)).
   inv H. exists v. reflexivity.
   inv H.

 - unfold evaluate in H. simp eval_or_match in H.
   inv H. exists (Closure env v e). reflexivity.

 - unfold evaluate in H. simp eval_or_match in H.
   break_let.
   apply Forall''_rev in X.
   induction X.
   simp eval_or_match in Heqp.
   inv Heqp.
   break_if.
   simpl in H.
   inv H.
   simpl in *.
   inv H.
   destruct r.
   break_if.
   break_match.
   break_let.
   apply IHf in H.
   apply H.
   inv H.
   break_match.
   break_let.
   break_let.
   inv H.
   destruct r.
   simpl in *.
   inv H2.
   exists v. reflexivity.
   inv H2.
   inv H.
   inv H.

 - unfold evaluate in H. simp eval_or_match in H.
   break_let.
   destruct r.
   apply IHe in Heqp.
   destruct Heqp.
   rewrite H0 in *.
   induction X.
   simp eval_or_match in H.
   inv H.
   destruct x0.
   simp eval_or_match in *.
   break_if.
   break_match.
   apply IHX.
   apply H.
   inv H.
   apply p in H.
   apply H.
   inv H.
   inv H.

 - unfold evaluate in H. simp eval_or_match in H.
Qed.

Theorem eval_or_match_cons : forall (st : state A) (env : sem_env val) (e : exp) (es : list exp) (f : nat),
   eval_or_match true (e::es) f st env uu uu =
     match eval_or_match true [e] f st env uu uu with
     | (st', Rval vs) =>
      match eval_or_match true es f st' env uu uu with
       | (st'', Rval vs') => (st'', Rval (vs++vs'))
       | err => err
      end
     | err => err
     end.
Proof.
  unfold evaluate.
  intros. revert e st.
  destruct es; intros; simpl.
  destruct (eval_or_match true [e] f st env uu uu).
  destruct r.
  simp eval_or_match.
  rewrite app_nil_r.
  congruence.
  congruence.
  simp eval_or_match.
  destruct (eval_or_match true [e0] f st env uu uu) eqn:eval1.
  destruct r.
  apply eval_or_match_sing in eval1.
  destruct eval1. rewrite H. simpl.
  congruence.
  congruence.
Qed.

Theorem evaluate_cons : forall (st : state A) (env : sem_env val) (e : exp) (es : list exp) (f : nat),
   evaluate (e::es) f st env =
     match evaluate [e] f st env with
     | (st', Rval vs) =>
      match evaluate es f st' env with
       | (st'', Rval vs') => (st'', Rval (vs++vs'))
       | err => err
      end
     | err => err
     end.
Proof.
  unfold evaluate.
  apply eval_or_match_cons.
Qed.

Theorem eval_or_match_app : forall (st : state A) env xs ys f,
   eval_or_match true (xs ++ ys) f st env uu uu =
     match eval_or_match true xs f st env uu uu with
     | (st', Rval vs) =>
       match eval_or_match true ys f st' env uu uu with
       | (s'', Rval vs') => (s'', Rval (vs++vs'))
       | err => err
       end
     | err => err
     end.
Proof.
  intros. revert ys st.
  induction xs; intros. simpl.
  unfold evaluate.
  simp eval_or_match.
  destruct (eval_or_match true ys f st env uu uu).
  destruct r; simpl; congruence.
  rewrite eval_or_match_cons.
  simpl.
  rewrite eval_or_match_cons.
  destruct (eval_or_match true [a] f st env uu uu).
  destruct r.
  rewrite IHxs.
  destruct (eval_or_match true xs f s env uu uu ).
  destruct r.
  destruct (eval_or_match true ys f s0 env uu uu).
  destruct r.
  rewrite app_assoc_reverse.
  congruence.
  congruence.
  congruence.
  congruence.
Qed.

Theorem evaluate_app : forall (st : state A) env xs ys f,
   evaluate (xs ++ ys) f st env =
     match evaluate xs f st env with
     | (st', Rval vs) =>
       match evaluate ys f st' env with
       | (s'', Rval vs') => (s'', Rval (vs++vs'))
       | err => err
       end
     | err => err
     end.
Proof.
  unfold evaluate; apply eval_or_match_app.
Qed.

(* Require Import Program. *)

Lemma eval_or_match_inc_fuel_val : forall (f : nat) (sel : bool)
                                     (es : if sel then list exp else list (pat * exp)) (st st' : state A)
                                     (env : sem_env val) (match_v err_v : val) (vs : list val),
    eval_or_match sel es f st env match_v err_v = (st', Rval vs) ->
    eval_or_match sel es (S f) st env match_v err_v = (st', Rval vs).
Proof.
  intros.
  funelim (eval_or_match sel es f st env match_v err_v).
  - simp eval_or_match in *.
  - simp eval_or_match in *.
    break_if.
    + destruct (eval_or_match true (rev l) fuel st env uu uu) eqn:eval1.
      rewrite <- eval1 in H.
      destruct r.
      * apply H in eval1.
        rewrite eval1.
        break_match.
        assumption.
        inv Heqcall.
        inv H0.
      * inv Heqcall.
        inv H0.
    + inv Heqcall.
      inv H0.
  - simp eval_or_match. rewrite Heqcall. assumption.
  - simp eval_or_match. rewrite Heqcall. assumption.
  - rewrite <- Heqcall in H. inv H.
  - simp eval_or_match in *.
    destruct (eval_or_match true (rev l0) n st env uu uu) eqn:eval1.
    destruct r.
    * rewrite <- eval1 in H.
      apply H in eval1.
      rewrite eval1.
      break_if.
      + break_match.
        -- break_let.
           simpl in H0.
           specialize (H0 s (Rval vs) vs e p s0 e0 n true [e0] s st' s0 uu uu vs H1).
           apply H0. reflexivity.
           reflexivity.
        -- inv H1.
      + break_match. auto.
        inv H1.
    * inv H1.
  - simp eval_or_match in *.
    destruct (eval_or_match true [e0] fuel st env uu uu) eqn:eval1.
    rewrite <- eval1 in H.
    destruct r.
    apply H in eval1.
    rewrite eval1.
    destruct l.
    assumption.
    apply H0 with s v; try assumption; try reflexivity.
    apply (Rval vs).
    inv H1.
  - simp eval_or_match in *.
  - simp eval_or_match in *.
    destruct (eval_or_match true [e] fuel st env uu uu) eqn:eval1.
    rewrite <- eval1 in H.
    destruct r.
    apply H in eval1.
    rewrite eval1.
    destruct (eval_or_match true (e0::l) fuel s env uu uu) eqn:eval2.
    destruct r.
    specialize (H0 s (Rval vs) vs fuel true (e0::l) s s0 env uu uu l1 eval2).
    assert (eval_or_match true (e0 :: l) fuel s env uu uu =
            eval_or_match true (e0 :: l) fuel s env uu uu) by congruence.
    rewrite H0. assumption.
    reflexivity.
    congruence.
    inv H1.
    inv H1.
  - simp eval_or_match in *.
  - simp eval_or_match in *.
    clear Heqcall.
    break_match.
    break_match.
    apply H.
    assumption.
    assumption.
    inv H1.
    specialize (H0 n a fuel true [e] st st' {| sev := nsAppend (alist_to_ns a) (sev env); sec := sec env |} uu uu vs H1).
    apply H0; try reflexivity.
    congruence.
Qed.

Lemma eval_or_match_inc_fuel_res : forall (f : nat) (sel : bool)
                                     (es : if sel then list exp else list (pat * exp)) (st st' : state A)
                                     (env : sem_env val) (match_v err_v : val) (res : result (list val) val),
    res <> Rerr (Rabort Rtimeout_error) ->
    eval_or_match sel es f st env match_v err_v = (st', res) ->
    eval_or_match sel es (S f) st env match_v err_v = (st', res).
Proof.
  intros.
  funelim (eval_or_match sel es f st env match_v err_v).
  - simp eval_or_match in *.
  - simp eval_or_match in *.
    clear Heqcall.
    break_match.
    destruct (eval_or_match true (rev l) fuel st env uu uu) eqn:eval1.
    rewrite <- eval1 in H.
    apply H in eval1.
    rewrite eval1.
    destruct r.
    break_match; assumption.
    inv H1.
    reflexivity.
    destruct r.
    congruence.
    congruence.
    congruence.
  - simp eval_or_match in *.
  - simp eval_or_match in *.
  - simp eval_or_match in *. congruence.
  - simp eval_or_match in *.
    destruct (eval_or_match true (rev l0) n st env uu uu) eqn:eval1.
    rewrite <- eval1 in H.
    apply H in eval1.
    rewrite eval1.
    break_match.
    + break_if.
      * break_match.
        -- break_let.
           specialize (H0 s res l e p s0 e0 n true [e0] s st' s0 uu uu res H1 H2).
           apply H0; reflexivity.
        -- congruence.
      * break_match; auto.
    + congruence.
    + destruct r; congruence.
  - simp eval_or_match in *.
    destruct (eval_or_match true [e0] fuel st env uu uu) eqn:eval1.
    rewrite <- eval1 in H.
    apply H in eval1.
    rewrite eval1.
    destruct r; auto.
    destruct l; auto.
    specialize (H0 s res l v l fuel false l1 s st' env v bind_exn_v res H1 H2).
    apply H0; reflexivity.
    destruct r; congruence.
  - simp eval_or_match in *.
  - simp eval_or_match in *.
    clear Heqcall.
    destruct (eval_or_match true [e] fuel st env uu uu) eqn:eval1.
    rewrite <- eval1 in H.
    apply H in eval1.
    rewrite eval1.
    destruct r.
    + destruct (eval_or_match true (e0::l) fuel s env uu uu) eqn:eval2.
      destruct r.
      * destruct l0.
        -- assert (HneqValErr : ((Rval l1 : result (list val) val) <> Rerr (Rabort Rtimeout_error))) by congruence.
        specialize (H0 s (Rval l1) l1 fuel true (e0::l) s s0 env uu uu (Rval l1) HneqValErr eval2).
        rewrite H0; congruence.
        -- assert (HneqValErr : ((Rval l1 : result (list val) val) <> Rerr (Rabort Rtimeout_error))) by congruence.
           specialize (H0 s (Rval (l1)) l1 fuel true (e0::l) s s0 env uu uu (Rval (l1)) HneqValErr eval2).
           rewrite H0; congruence.
        * inv H2.
          specialize (H0 s (Rerr e1) l0 fuel true (e0::l) s st' env uu uu (Rerr e1) H1 eval2).
          rewrite H0. reflexivity.
          reflexivity.
          reflexivity.
    + congruence.
    + destruct r; congruence.
  - simp eval_or_match in *.
  - simp eval_or_match in *.
    break_if.
    + break_match.
      * apply H; assumption.
      * congruence.
      * specialize (H0 n a fuel true [e] st st' {| sev := nsAppend
                                                            (alist_to_ns a)
                                                            (sev env);
                                                   sec := sec env |}
                       uu uu res H1 H2).
        apply H0; reflexivity.
    + congruence.
Qed.

Lemma evaluate_inc_fuel_res : forall (f : nat) (es : list exp) (st st' : state A)
                                (env : sem_env val) (res : result (list val) val),
    res <> Rerr (Rabort Rtimeout_error) ->
    evaluate es f st env = (st', res) ->
    evaluate es (S f) st env = (st', res).
Proof.
  intros.
  apply eval_or_match_inc_fuel_res; assumption.
Qed.

Lemma more_fuel_same_result : forall (n f: nat) (st st' : state A) (env : sem_env val) (res : result (list val) val) (es : list exp),
    res <> Rerr (Rabort Rtimeout_error) ->
    eval_or_match true es f st env uu uu = (st', res) ->
    eval_or_match true es f st env uu uu = eval_or_match true es (n+f) st env uu uu.
Proof.
  induction n.
  - intros. reflexivity.
  - intros.
    rewrite H0.
    apply eval_or_match_inc_fuel_res in H0; try assumption.
    rewrite <- H0.
    rewrite plus_Snm_nSm.
    apply IHn with st' res; try assumption.
Qed.

Theorem ELannot_does_nothing : forall (e : exp) (l : locs) (f : nat) (st : state A) (env : sem_env val),
    evaluate [ELannot e l] f st env = evaluate [e] f st env.
Proof.
  intros e l f st env.
  unfold evaluate.
  simp eval_or_match.
  congruence.
Qed.

Ltac more_fuel_same_result_quick :=
  match goal with
  | [ H0 : evaluate ?es ?f ?st ?env = (?st',?res), H1 : context[evaluate ?es ?f' ?st ?env] |- _ ] =>
    let H := fresh "H" in
    let Hass := fresh "Hass" in
    let Hass0 := fresh "Hass0" in
    assert (H : evaluate es f st env = (st',res)) by apply H0;
    assert (Hass : f <= f') by omega;
    assert (Hass0 : res <> (Rerr (Rabort Rtimeout_error))) by (simpl; congruence);
    apply (more_fuel_same_result f f' st st' env res es Hass Hass0) in H;
    rewrite H in H1;
    clear Hass Hass0 H
  end.

Ltac match_exp_same :=
  match goal with
  | [H : context[ match ?x with
                  | ECon _ _ => ?y
                  | EVar _   => ?y
                  | EFun _ _ => ?y
                  | EApp _ _ => ?y
                  | EMat _ _ => ?y
                  | ELannot _ _ => ?y
                  end] |- _ ] =>
    let Hass := fresh "Hass" in
    assert (Hass : match x with
                   | ECon _ _ => y
                   | EVar _   => y
                   | EFun _ _ => y
                   | EApp _ _ => y
                   | EMat _ _ => y
                   | ELannot _ _ => y
                   end
                   = y) by (destruct x; reflexivity);
    rewrite Hass in H; clear Hass
  end.

(* Theorem eval_or_match_len_exp_len_val : forall (es : list exp) (f : nat) (st st' : state A) (env : sem_env val) (match_v err_v : val) (vs : list val), *)
(*   eval_or_match true es f st env match_v err_v = (st', Rval vs) -> *)
(*   length es = length vs. *)
(* Proof. *)
(*   intros. *)
(*   funelim (eval_or_match true es f st env match_v err_v); try reflexivity. *)
(*   - simp eval_or_match in H. inv H. reflexivity. *)
(*   - simpl in *. *)
(*     break_if. *)

(*     + rewrite H1 in Heqcall. *)
(*       break_match; try congruence. *)
(*       * apply H with st'. *)
(*         assumption. *)
(*         assumption. *)
(*       * apply eval_or_match_sing in Heqcall. *)
(*         destruct Heqcall. *)
(*         rewrite H2. reflexivity. *)
(*     + rewrite H1 in Heqcall. congruence. *)
(* Qed. *)

(* IDEA: If I can get to a constructor value from a certain starting state and also the. Then there exists a shortest expression in that state that evaluates to that value *)

(* Playing with type checking *)
Definition noTimeout e f (st : state A) env st' :=
  eval_or_match true [e] f st env uu uu <> (st', Rerr (Rabort Rtimeout_error)).

Definition nat_cake_exp (t f : nat) (st : state A) (env : sem_env val) (n : nat) (e : exp) :=
  exists (st' : state A) (v : val),
    evaluate [e] f st env = (st', Rval [v]) /\ nat_rel_cake_nat t n v.

Lemma nat_cake_exp_inc : forall (t f : nat) (st : state A) (env : sem_env val) (n : nat) (e : exp),
    nat_cake_exp t f st env n e ->
    nat_cake_exp t (S f) st env n e.
Proof.
  unfold nat_cake_exp.
  intros.
  destruct H. destruct H.
  destruct H.
  apply eval_or_match_inc_fuel_res in H; try congruence.
  exists x. exists x0.
  split; assumption.
Qed.

Theorem ctor_canonical_values :
  forall stmp tvs ctm tenvS v ts ti tvs' ts',
  type_v tvs ctm tenvS v (Tapp ts ti) ->
  ctMap_ok ctm ->
  lookup stamp_eq_dec stmp ctm = Some (tvs',ts',ti) ->
  (exists cn n vs, stamp_same_type stmp (TypeStamp cn n) /\ v = Conv (Some (TypeStamp cn n)) vs) \/
  (exists n vs, stamp_same_type stmp (ExnStamp n) /\ v = Conv (Some (ExnStamp n)) vs).
Proof.
  (* intros. *)
  (* unfold ctMap_ok in H0. destruct H0. destruct H2. destruct H3. *)
  (* inv H. *)
  (* - destruct stmp0. *)
  (*   + left. exists c. exists n. exists vs. *)
  (*     split. *)
  (*     eapply H4. *)
  (*     apply H1. *)
  (*     apply H14. *)
  (*     reflexivity. *)
  (*   + right. exists n. exists vs. *)
  (*     split. *)
  (*     eapply H4. *)
  (*     apply H1. apply H14. *)
  (*     reflexivity. *)
  (* - destruct stmp. *)
  (*   apply H3 in H1. simpl in H1. destruct H1. *)
  (*   right. right. *)
  (*   right. right. *)
  (*   right. right. *)
  (*   right. left. reflexivity. *)
  (*   apply H2 in H1. *)
  (*   destruct H1. *)
  (*   discriminate. *)
  (* - destruct stmp. *)
  (*   + apply H3 in H1. *)
  (*     destruct H1. *)
  (*     simpl; auto. *)
  (*   + apply H2 in H1. *)
  (*     destruct H1. *)
  (*     discriminate. *)
  (* - destruct H10. *)
  (*   + inv H11. *)
  (*   + destruct (string_dec n fn); subst. *)
  (*     * simpl in H11. destruct (string_dec fn fn). *)
  (*       inv H11. *)
Abort.

(* WHY IS THIS SO DIFFICULT? *)
Lemma rev_sing : forall (T : Type) (l : list T) (t : T),
    rev l = [t] <-> l = [t].
Proof.
  destruct l; intros.
  - split; intros.
    + inv H.
    + inv H.
  - split; intros.
    + simpl in H.
      destruct l.
      * inv H. reflexivity.
      * simpl in H.
        destruct (rev l).
        -- inv H.
        -- inv H.
           destruct l0; simpl in *; inv H2.
    + destruct l. simpl. congruence.
      inv H.
Qed.

(* The problem here is that even if we know that the entire expression 'e' typechecks to some type ty, *)
(* we don't know what that type is or what types any of its arguments may have. *)
(* A possible solution is some sort of environment check that ensures that only certain values are *)
(* attainable *)

Lemma nat_inv_specific : forall (e :exp) (f ty : nat) (st' : state A) (v : val),
    (* Possibly more restrictions here -> *)
    eval_or_match true [e] f my_st my_env uu uu = (st', Rval [(Conv (Some (TypeStamp "S" ty)) [v])]) ->
    exists e', eval_or_match true [e'] f my_st my_env uu uu = (st', Rval [v]).
Proof.
Admitted.

Lemma not_diverges_inc_fuel : forall f' f es st env,
  eval_or_match true es f st env uu uu = eval_or_match true es f' st env uu uu.
Proof.
Admitted.


Lemma environments_same : forall f es st env,
    (* Definitiely more restrictions here -> *)
    eval_or_match true es f st env uu uu = eval_or_match true es f st my_env uu uu.
Proof.
Admitted.

Theorem plus_vs_cake_plus : forall (m n f : nat) (m_exp n_exp : exp) (m_val n_val m_n_val : val),
    evaluate [m_exp] f my_st my_env = (my_st, Rval [m_val]) ->
    evaluate [n_exp] f my_st my_env = (my_st, Rval [n_val]) ->
    nat_rel_cake_nat 0 m m_val ->
    nat_rel_cake_nat 0 n n_val ->
    evaluate [(EApp (Opapp) ((EApp (Opapp) ((EVar (Short ("plus"%string)))::m_exp::nil))::n_exp::nil))]
             f my_st my_env =
    (my_st, Rval [m_n_val]) ->
    nat_rel_cake_nat 0 (m+n) m_n_val.
Proof.
  intros.
  unfold evaluate in *.
  apply eval_or_match_inc_fuel_res in H3; try congruence.
  apply eval_or_match_inc_fuel_res in H3; try congruence.
  apply eval_or_match_inc_fuel_res in H3; try congruence.
  apply eval_or_match_inc_fuel_res in H3; try congruence.
  simp eval_or_match in *; simpl in *.
  rewrite eval_or_match_cons in H3; simpl in *.
  apply eval_or_match_inc_fuel_res in H0; try congruence.
  apply eval_or_match_inc_fuel_res in H0; try congruence.
  apply eval_or_match_inc_fuel_res in H0; try congruence.
  rewrite H0 in H3.
  simp eval_or_match in *; simpl in *.
  simp eval_or_match in *; simpl in *.
  apply eval_or_match_inc_fuel_res in H; try congruence.
  apply eval_or_match_inc_fuel_res in H; try congruence.
  rewrite H in H3.
  simp eval_or_match in *; simpl in *.
  simp eval_or_match in *; simpl in *.
  simp eval_or_match in *; simpl in *.
  Opaque stamp_eq_dec.
  simp eval_or_match in *; simpl in *.
  simp eval_or_match in *; simpl in *.
  simp eval_or_match in *; simpl in *.
  generalize dependent m_exp.
  generalize dependent m_n_val.
  induction H1.
  - intros. Transparent stamp_eq_dec.
    simp eval_or_match in H3; simpl in H3.
    simp eval_or_match in H3; simpl in H3.
    inv H3.
    apply H2.

  - intros. simpl in H3.
    simp eval_or_match in H3; simpl in H3.
    break_let.
    destruct r.
    assert (exists v, l = [v]). {
      eapply eval_or_match_sing.
      apply Heqp. }
    assert (@nsEmpty modN varN val = []) by reflexivity.
    simp eval_or_match in Heqp; simpl in Heqp.
    simp eval_or_match in Heqp; simpl in Heqp.
    simp eval_or_match in Heqp; simpl in Heqp.
    simp eval_or_match in Heqp; simpl in Heqp.
    simp eval_or_match in Heqp; simpl in Heqp.
    Opaque stamp_eq_dec.
    simp eval_or_match in Heqp; simpl in Heqp.
    simp eval_or_match in Heqp; simpl in Heqp.
    simp eval_or_match in Heqp; simpl in Heqp.
    simp eval_or_match in H3; simpl in H3.
    destruct H4.
    inv H3.
    apply nat_inv_specific in H.
    destruct H.
    subst; simpl in *.
    break_match.
    break_match.
    inv Heqp.
    inv Heqp.
    apply evaluate_inc_fuel_res in Heqp.
    rewrite H5 in Heqp.
    specialize (IHnat_rel_cake_nat x Heqp x0 H).
    constructor. assumption.
    congruence.
    inv Heqp.
    apply evaluate_inc_fuel_res in Heqp.
    rewrite H5 in Heqp.
    specialize (IHnat_rel_cake_nat x Heqp x0 H).
    constructor.
    assumption.
    congruence.
    inv H3.
Qed.
